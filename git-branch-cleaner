#!/bin/bash

set -euo pipefail

# Default configuration
DEFAULT_STALE_DAYS=30
DEFAULT_CONFIG_FILE="$HOME/.git-branch-cleaner.conf"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration variables
STALE_DAYS=$DEFAULT_STALE_DAYS
CHECK_PRS=false
GITHUB_TOKEN=""
DRY_RUN=false
REPOS=()
EXCLUDE_BRANCHES="main|master|develop|dev"

show_help() {
    cat << EOF
Git Branch Cleaner - Find and delete stale branches

USAGE:
    git-branch-cleaner [OPTIONS] [REPO_PATHS...]

OPTIONS:
    -d, --days DAYS         Number of days to consider a branch stale (default: $DEFAULT_STALE_DAYS)
    -p, --check-prs         Check for active pull requests (requires GitHub token)
    -t, --token TOKEN       GitHub token for PR checking
    -n, --dry-run          Show what would be deleted without actually deleting
    -e, --exclude PATTERN   Regex pattern for branches to exclude (default: $EXCLUDE_BRANCHES)
    -c, --config FILE       Use config file (default: $DEFAULT_CONFIG_FILE)
    -h, --help             Show this help message

EXAMPLES:
    # Scan current repo for branches older than 30 days
    git-branch-cleaner

    # Scan multiple repos with custom staleness period
    git-branch-cleaner -d 14 /path/to/repo1 /path/to/repo2

    # Check for active PRs before suggesting deletion
    git-branch-cleaner -p -t ghp_your_token_here

    # Dry run to see what would be deleted
    git-branch-cleaner -n

EOF
}

log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

load_config() {
    if [[ -f "$1" ]]; then
        log "Loading config from $1"
        # shellcheck source=/dev/null
        source "$1"
    fi
}

is_git_repo() {
    local repo_path="$1"
    [[ -d "$repo_path/.git" ]] || git -C "$repo_path" rev-parse --git-dir >/dev/null 2>&1
}

get_stale_branches() {
    local repo_path="$1"
    local cutoff_date
    
    cutoff_date=$(date -d "$STALE_DAYS days ago" +%Y-%m-%d 2>/dev/null || date -v-${STALE_DAYS}d +%Y-%m-%d 2>/dev/null)
    
    if [[ -z "$cutoff_date" ]]; then
        error "Failed to calculate cutoff date"
        return 1
    fi
    
    log "Finding branches older than $cutoff_date in $repo_path"
    
    # Get all local branches with their last commit dates, excluding protected branches
    git -C "$repo_path" for-each-ref --format='%(refname:short)|%(committerdate:short)|%(authorname)' refs/heads/ | \
    while IFS='|' read -r branch date author; do
        # Skip excluded branches
        if [[ "$branch" =~ ^($EXCLUDE_BRANCHES)$ ]]; then
            continue
        fi
        
        # Check if branch is stale
        if [[ "$date" < "$cutoff_date" ]]; then
            echo "$branch|$date|$author"
        fi
    done
}

check_pr_status() {
    local repo_path="$1"
    local branch="$2"
    
    if [[ "$CHECK_PRS" == false ]] || [[ -z "$GITHUB_TOKEN" ]]; then
        return 1  # No PR check or no token
    fi
    
    # Extract repo info from git remote
    local remote_url
    remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
    
    if [[ -z "$remote_url" ]]; then
        return 1
    fi
    
    # Parse GitHub repo from URL
    local repo_info
    if [[ "$remote_url" =~ github.com[:/]([^/]+)/([^/.]+) ]]; then
        repo_info="${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    else
        return 1
    fi
    
    # Check for open PRs for this branch
    local pr_count
    pr_count=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
        "https://api.github.com/repos/$repo_info/pulls?head=$repo_info:$branch&state=open" | \
        jq length 2>/dev/null || echo "0")
    
    [[ "$pr_count" -gt 0 ]]
}

select_branches_to_delete() {
    local repo_path="$1"
    local stale_branches=("${@:2}")
    local selected_branches=()
    
    if [[ ${#stale_branches[@]} -eq 0 ]]; then
        log "No stale branches found in $repo_path"
        return 0
    fi
    
    echo
    echo -e "${YELLOW}Stale branches found in $repo_path:${NC}"
    echo "----------------------------------------"
    
    local i=1
    local branch_info=()
    
    for branch_data in "${stale_branches[@]}"; do
        IFS='|' read -r branch date author <<< "$branch_data"
        
        local pr_status=""
        if check_pr_status "$repo_path" "$branch"; then
            pr_status=" ${GREEN}(has open PR)${NC}"
            continue  # Skip branches with open PRs
        fi
        
        echo -e "$i) $branch (last commit: $date by $author)$pr_status"
        branch_info+=("$branch")
        ((i++))
    done
    
    if [[ ${#branch_info[@]} -eq 0 ]]; then
        log "All stale branches have open PRs, nothing to delete"
        return 0
    fi
    
    echo
    echo "Enter branch numbers to delete (e.g., 1,3,5 or 1-3 or 'all' or 'none'):"
    read -r selection
    
    case "$selection" in
        "none"|"")
            log "No branches selected for deletion"
            return 0
            ;;
        "all")
            selected_branches=("${branch_info[@]}")
            ;;
        *"-"*)
            # Range selection (e.g., 1-3)
            local start end
            IFS='-' read -r start end <<< "$selection"
            for ((j=start; j<=end && j<=${#branch_info[@]}; j++)); do
                selected_branches+=("${branch_info[$((j-1))]}")
            done
            ;;
        *","*)
            # Comma-separated selection
            IFS=',' read -ra indices <<< "$selection"
            for index in "${indices[@]}"; do
                if [[ "$index" =~ ^[0-9]+$ ]] && [[ "$index" -ge 1 ]] && [[ "$index" -le ${#branch_info[@]} ]]; then
                    selected_branches+=("${branch_info[$((index-1))]}")
                fi
            done
            ;;
        *)
            # Single number
            if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le ${#branch_info[@]} ]]; then
                selected_branches+=("${branch_info[$((selection-1))]}")
            fi
            ;;
    esac
    
    if [[ ${#selected_branches[@]} -eq 0 ]]; then
        log "No valid branches selected"
        return 0
    fi
    
    echo
    echo -e "${RED}Selected branches for deletion:${NC}"
    printf '%s\n' "${selected_branches[@]}"
    
    if [[ "$DRY_RUN" == true ]]; then
        warn "DRY RUN: Would delete ${#selected_branches[@]} branches"
        return 0
    fi
    
    echo
    echo -e "${RED}WARNING: This will permanently delete the selected branches!${NC}"
    echo "Are you sure? (yes/no)"
    read -r confirmation
    
    if [[ "$confirmation" == "yes" ]]; then
        delete_branches "$repo_path" "${selected_branches[@]}"
    else
        log "Deletion cancelled"
    fi
}

delete_branches() {
    local repo_path="$1"
    local branches=("${@:2}")
    local deleted_count=0
    
    for branch in "${branches[@]}"; do
        if git -C "$repo_path" branch -D "$branch" >/dev/null 2>&1; then
            success "Deleted branch: $branch"
            ((deleted_count++))
        else
            error "Failed to delete branch: $branch"
        fi
    done
    
    success "Deleted $deleted_count out of ${#branches[@]} branches in $repo_path"
}

process_repo() {
    local repo_path="$1"
    
    if ! is_git_repo "$repo_path"; then
        error "Not a git repository: $repo_path"
        return 1
    fi
    
    log "Processing repository: $repo_path"
    
    # Fetch latest info from remotes
    if git -C "$repo_path" remote >/dev/null 2>&1; then
        log "Fetching latest remote information..."
        git -C "$repo_path" fetch --all --prune >/dev/null 2>&1 || warn "Failed to fetch from remotes"
    fi
    
    # Get stale branches
    local stale_branches
    mapfile -t stale_branches < <(get_stale_branches "$repo_path")
    
    select_branches_to_delete "$repo_path" "${stale_branches[@]}"
}

main() {
    local config_file="$DEFAULT_CONFIG_FILE"
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--days)
                STALE_DAYS="$2"
                shift 2
                ;;
            -p|--check-prs)
                CHECK_PRS=true
                shift
                ;;
            -t|--token)
                GITHUB_TOKEN="$2"
                CHECK_PRS=true
                shift 2
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -e|--exclude)
                EXCLUDE_BRANCHES="$2"
                shift 2
                ;;
            -c|--config)
                config_file="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                REPOS+=("$1")
                shift
                ;;
        esac
    done
    
    # Load configuration file
    load_config "$config_file"
    
    # If no repos specified, use current directory
    if [[ ${#REPOS[@]} -eq 0 ]]; then
        REPOS=(".")
    fi
    
    # Check for required tools
    if [[ "$CHECK_PRS" == true ]] && ! command -v jq >/dev/null 2>&1; then
        error "jq is required for PR checking but not installed"
        exit 1
    fi
    
    if [[ "$CHECK_PRS" == true ]] && ! command -v curl >/dev/null 2>&1; then
        error "curl is required for PR checking but not installed"
        exit 1
    fi
    
    log "Git Branch Cleaner starting..."
    log "Stale threshold: $STALE_DAYS days"
    log "Check PRs: $CHECK_PRS"
    log "Dry run: $DRY_RUN"
    
    # Process each repository
    for repo in "${REPOS[@]}"; do
        process_repo "$repo"
        echo
    done
    
    log "Git Branch Cleaner finished"
}

# Check if script is being sourced or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi